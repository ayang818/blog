---

title: Java中的锁优化(1)

date: 2019-10-10 20:47:18

tags: [并发编程,Java]

---



>  部分内容参考《深入理解Java虚拟机》第五部分——高效并发



## 锁优化

高效并发是JDK1.5-JDK1.6的一个重要改进，HotSpot虚拟机团队在开发这个版本的时候花了大量的精力去实现各种锁优化技术，比如适应性自旋，锁消除，锁粗化，轻量级锁和偏向锁等，这些技术都是为了在线程之间更加高效的共享数据，以及解决竞争问题。这篇文章将以概念介绍为主。



### 自旋锁与自适应自旋

我们知道往往在讨论锁的互斥同步的时候，其对性能最大的损耗就是阻塞的实现，挂起线程和回复线程都要进入操作系统内核态完成。然而其实有些阻塞只是很短的时间，没有必要挂起线程，所以这个时候可以选择让线程进入一个忙循环，知道阻塞条件结束，这就是所谓的自旋锁，关于自旋的代码可以参照我的这篇文章——[Java原子性操作以及不如来手写一个简单锁](https://ayang818.gitee.io/blog/2019/07/16/Java原子性操作以及简单的锁的实现-1/)，由于自旋是不断重试的过程，要是一直重试失败，就会造成CPU资源浪费，所以自旋需要设置次数；而所谓自适应自旋就是指根据前一次在同一个锁上的自旋时间，以及锁的拥有者的状态来判断自旋次数或是否自旋，这些在JDK1.6中都已经帮我们实现了。


<!-- more -->
### 锁消除

锁消除指虚拟机既时编译器在运行时，会对被检测到不可能存在共享数据竞争的锁进行锁消除，例如下面一段代码

```java
public class LockClean {
    public static void main(String[] args) {
        String s1 = "1";
        String s2 = "2";
        String s3 = "3";
        String string = concatString(s1, s2, s3);
        System.out.println(string);
    }

    public static String concatString(String s1, String s2, String s3) {
        return s1 + s2 + s3;
    }
}
```

这段代码看上去没有任何同步措施，但是我们知道，String是一个final类，是不可改变的，加的操作是通过StringBuilder或StringBuffer的append()来实现的，你可以看一下使用java反编译出来的结果。而StringBuffer其实是一个线程安全类，他的每个方法都有synchronized修饰。但是事实上所有的StringBuffer对象都只会在调用该方法的线程中，无法逃逸到其它线程，所以其实是不会有竞态条件的，这个锁就可以被安全的擦除掉，这就是锁消除。



### 锁粗化

在阿里巴巴Java开发手册中有这样的话

> 高并发时，同步调用需要去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。
>
> 说明： 尽可能使加锁的代码块工作量尽量小，避免在锁代码块中调用RPC方法

就是说锁的粒度要尽可能小，但是并不需要为了锁的粒度小而频繁加锁。Java虚拟机会检测一些零碎的连续操作对同一个对象加锁的代码，见他们的锁合并，这就是锁粗化。