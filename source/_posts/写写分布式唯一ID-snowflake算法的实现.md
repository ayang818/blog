---
title: '浅析分布式唯一ID生成算法——snowflake的实现'
date: 2019-12-14 20:29:25
tags: [分布式理论]
---
> 开头先放一个snowflake的实现——[仓库地址](https://github.com/ayang818/snowflake-id-generator/tree/master)
## 分布式唯一Id是什么
分布式唯一Id其实是一个分布式系统里面的一个不可或缺的元素，他一般具有如下几个特性

- 同一业务的全局唯一性(globally unique)
- 包含时间信息(timestamp)
- 递增有序性(incremented and ordered)

## 分布式唯一Id有什么用
这样一个分布式唯一Id，在一个分布式系统中的作用都有些什么呢。

举个例子，比如说业务量大了要做分库分表了，拿MyCat这个中间件举例，你对接了MyCat这个中间件后，你是接触不到MyCat后面被取余策略或其他策略分离的表的。MyCat呈现给你的仍然是一张表，但是却是分离的表的合并。 那这个时候你后面的数据库的主键要是还是和单机的策略一样，仍然是普通的auto_increment 1的话，你的分割后的每张表都会有重复的Id。
比如说有一组订单表order_1, order_2

<!-- more -->

对于order_1，有

|id|message|
|---|---|
|1|x|
|2|xx|

对于order_2，有

|id|message|
|---|---|
|1|xxx|
|2|xxxx|

但是MyCat呈现给你的视图却是order

|id|message|
|---|---|
|1|xxx|
|2|xxxx|
|1|x|
|2|xx|

由于你的应用程序对接的是MyCat，这样你的根据Id查询的策略就会出现很大的问题
```sql
select from order where id = 1;
```
这样一条筛选居然可以有两个结果，这就意味着一个订单号对应着两个交易，这在业务上显然是不符合实际的。这个时候我们就需要分布式唯一Id来解决这个问题。

## 如何实现一个分布式唯一Id

- 最简单的实现
```java
UUID.randomUUID().toString();
```
关于UUID.randomUUID()中一些有意思的点的还可以看看我的这篇文章[使用0xff来保证二进制补码的一致性](https://ayang818.gitee.io/blog/2019/12/14/%E4%BD%BF%E7%94%A80xff%E6%9D%A5%E4%BF%9D%E8%AF%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/)

优点 : 
1. 简便
缺点 :
1. 无序非递增，对于数据库常用的B+树这种数据结构，插入的性能会比较差

- 数据库主键自增
使用数据库主键自增的操作也很简单，假设有三个数据库，分别是db1.db2,db3

那么可以这么设置

|数据库|起始id|自增不长|
|---|---|---|
|db1|1|3|
|db2|2|3|
|db3|3|3|

他们的id%3分别为1，2，3.不会重复。这种做法的优缺点如下

优点 :
1. 操作简单
缺点 :
1. 数据库容易成为性能瓶颈
2. 一旦某一个数据库宕机了，整体的可用性就下降了

- snowflake算法实现
snowflake算法生成的ID结构并不复杂，总共有64位。

其中一共有四部分
- 第一位，占用1bit，其值始终为0，没有实际作用
- 时间戳，占用41bit，精确到毫秒，总共可以容纳约140年的时间
- 工作机器ID，占用10bit，其中高位5bit是数据中心ID，地位5bit是工作节点ID，最多可以容纳1024个节点
- 序列号，占用2bit，这个值可在同一毫秒同一节点上从0开始不断累加，最多可以累加到4095。

所以是Snowflake在同一毫秒内最多可以生成1024 * 4096 = 1 << 22 = 4194304

snowflake的代码实现我自己也写一遍，已经贴在了文章的开头。

那么snowflake算法的优缺点都有什么呢

优点
- ID不依赖于第三方服务，而是依赖于各个高可用的服务节点，具备高性能与高可用特性
- ID的趋势是递增的，插入B+树这一数据结构的性能较好。

缺点
- ID的生成依赖于工作机器的系统时钟，一旦系统时钟出现了回拨，就可能会导致ID冲突或者ID乱序。